<html><head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!--SafClassName="docSection1Title"--><!--SafTocEntry="2.7 For Further Reading"-->
<link rel="STYLESHEET" type="text/css" href="FILES/style.css">
<link rel="STYLESHEET" type="text/css" href="FILES/docsafari.css">
<style type="text/css">	.tt1    {font-size: 10pt;}</style>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
	<a href="0321154959_ch02lev1sec6.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
	<a href="0321154959_ch02lev1sec8.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
<br>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"><A NAME="ch02lev1sec7"></A><H3 class="docSection1Title">2.7 For Further Reading</H3>
<P class="docText">The early work of David Parnas laid much of the conceptual foundation for what became the study of software architecture (see the sidebar <A class="docLink" HREF="#ch02sb03">Architecture D&eacute;j&agrave; Vu</A>). A quintessential Parnas reader would include his foundational article on information hiding [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry82">Parnas 72</A>] as well as his works on program families [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry84">Parnas 76</A>], the structures inherent in software systems [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry83">Parnas 74</A>], and introduction of the uses structure to build subsets and supersets of systems [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry85">Parnas 79</A>]. All of these papers can be found in the more easily accessible collection of his important papers [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry58">Hoffman 00</A>].</P>
<P class="docText">Software architectural patterns have been extensively catalogued in <span class="docEmphasis">Pattern-Oriented Software Architecture</span> [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry32">Buschmann 96</A>, <A class="docLink" HREF="0321154959_biblio01.html#biblio01entry94">Schmidt 00</A>].</P>
<P class="docText">Early papers on architectural views as used in industrial development projects are [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry99">Soni 95</A>] and [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry70">Kruchten 95</A>]. The former grew into a book [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry59">Hofmeister 00</A>] that presents a comprehensive picture of views as used in development and analysis. The latter grew into the Rational Unified Process, about which there is no shortage of references, both paper and online. A good one is [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry71">Kruchten 00</A>].</P>
<P class="docText">A discussion of architectural mismatch can be found in Garlan et al. [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry49">Garlan 95</A>]. Barry Boehm [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry19">Boehm 95</A>] discusses the process issues surrounding software architecture.</P>
<P class="docText">The Software Engineering Institute's software architecture Web page [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry96">SEI ATA</A>] provides a wide variety of software architecture resources and links, including a broad collection of definitions of the term.</P>
<P class="docText">Paulish [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry88">Paulish 02</A>] discusses the relationship of cost and schedule to the existence of an architecture.</P>
<P><A NAME="ch02sb03"></A><TABLE CELLSPACING="0" WIDTH="90%" BORDER="1"><TR><TD>
<H2 class="docSidebarTitle">Architecture D&eacute;j&agrave; Vu</H2>
<P class="docText">While architecture is undoubtedly a vital part of system development that is enjoying widespread attention at the moment, it must be pointed out that the field is plowing old ground in several areas. In many ways we are "discovering" fundamental principles that were laid out eloquently and convincingly over a quarter-century ago by Fred Brooks, Edsger Dijkstra, David Parnas, and others.</P>
<P class="docText">In programming, the term <span class="docEmphasis">architecture</span> was first used to mean a description of a computer system that applied equally to more than one system. It still carries this meaning today. In 1969, Fred Brooks and Ken Iverson called architecture the "conceptual structure of a computer &#8230; as seen by the programmer" [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry27">Brooks 69</A>]. A few years later, Brooks (crediting G. Blaauw for the term) defined architecture as "the complete and detailed specification of the user interface" [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry28">Brooks 75</A>]. A careful distinction was drawn between architecture and implementation. Quoting Blaauw, Brooks writes, "Where architecture tells <span class="docEmphasis">what</span> happens, implementation tells <span class="docEmphasis">how</span> it is made to happen." This distinction survives today, and in the era of object-oriented programming, it thrives.</P>
<P class="docText">The term <span class="docEmphasis">architecture</span> is still used today in some communities to refer to the user view of a system, but that is not what we mean by <span class="docEmphasis">software</span> architecture. The structure(s) contained in a software architecture is invisible to the system's end user. However, the conceptual separation between the <span class="docEmphasis">what</span> and the <span class="docEmphasis">how</span> applies. Software architecture is not concerned with how elements do what they do, just as the end user is not concerned with how the system does what it does. The notion of architecture as a common description of a class of systems (i.e., an abstraction, where all the instances are said to exhibit the architecture) remains at the heart of what we call software architecture today.</P>
<P class="docText">Also in 1968, Edsger Dijkstra was telling us to be concerned with how software is partitioned and structured as opposed to simply programming to produce a correct result [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry45">Dijkstra 68</A>]. He was writing about an operating system and introduced the idea of a layered structure, in which programs were grouped into layers and programs in one layer could communicate only with programs in adjacent layers. Dijkstra pointed out the elegant conceptual integrity exhibited by such an organization, resulting in increased ease of development and maintenance.</P>
<P class="docText">David Parnas advanced this line of observation with his fundamental contributions to software engineering in the early 1970s. In his work, more than anyone else's, is to be found many of the fundamental tenets and principles behind software architecture, including the following:</P>
<UL>
<LI><P class="docList">A design principle for how to break a system into elements to increase maintainability and (as we will see in <A class="docLink" HREF="0321154959_ch05.html#ch05">Chapter 5</A>) re-usability. If architecture has a fundamental principle, it is this one, which Parnas called information hiding [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry82">Parnas 72</A>].</P></LI>
<LI><P class="docList">The principle of using an element via its interface only, the conceptual basis of all object-based design [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry82">Parnas 72</A>].</P></LI>
<LI><P class="docList">An observation of the various structures to be found in software systems, with an admonition not to confuse them—a lesson often forgotten by today's "architecturists" [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry83">Parnas 74</A>].</P></LI>
<LI><P class="docList">Introduction of the uses structure, a principle for controlling the connections between elements in order to increase the extensibility of a system, as well as the ability to field subsets quickly and easily [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry85">Parnas 79</A>].</P></LI>
<LI><P class="docList">The principle of detection and handling of errors (now called exceptions) in component-based systems, which is the underlying approach of most modern programming languages [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry82">Parnas 72</A>, <A class="docLink" HREF="0321154959_biblio01.html#biblio01entry84">76</A>].</P></LI>
<LI><P class="docList">Viewing every program as a member of a family of programs, with principles for taking advantage of the commonalities among the members and ordering the design decisions so that the ones that need to be the easiest to revise are made last. The coarse structuring of the program—part of its architecture—comprises the set of early, family-wide design decisions [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry84">Parnas 76</A>].</P></LI>
<LI><P class="docList">Recognition that the structure of a system influences the qualities (such as reliability) of that system [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry84">Parnas 76</A>].</P></LI>
</UL>
<P class="docText">Now it is true, and Parnas would agree, that not all of the ideas in his papers were invented by him from whole cloth. About information hiding, for example, he has said that he was writing down what good programmers had been doing for a long time (especially operating systems programmers writing device drivers). However, taken as a body, Parnas's work is a coherent statement of the theme of software architecture: <span class="docEmphasis">Structure matters</span>. His insights form the backbone of software architecture as a study area, and no book on the subject would be complete without acknowledging his fundamental contributions.</P>
<P class="docText">Recently a colleague and I had a fine architectural discussion about what exactly constitutes the <span class="docEmphasis">interface</span> to a software element; clearly it is much more than the names of the programs you can call and the parameters they take. My colleague worked out that it is actually the set of assumptions that you can safely make about the element, and that these assumptions vary according to the context of the element's use. I agreed and pulled out Parnas's paper [<A class="docLink" HREF="0321154959_biblio01.html#biblio01entry81">Parnas 71</A>] in which he said precisely the same thing. My friend looked a little crestfallen for a moment and then said, "Now I know how Scott felt when he reached the South Pole and found Amundsen's flag already planted. He probably said, 'Oh, damn. And now I've got to eat my dogs.' "</P>
<P class="docText">Parnas's flag is planted deeply, and often, in our field. In the next chapter, we will present a case study of an architecture created by Parnas to put his ideas into practical use in a demanding real-world application. Even though it ran its course long ago, we know of no other single project that so clearly laid out and faithfully followed architectural principles such as engineering and maintaining separate structures to achieve quality goals; strict information hiding to achieve re-usable elements and a re-usable architecture; and painstaking specification of that architecture, its elements, and their relationships.</P>
<P class="docText">While Parnas and others laid the foundations, the field has taken its own turns in the interim. Experience with basic ideas leads to the refinement of those ideas, to embellishments rooted in practicalities, and to entirely new concepts. Thus, while Parnas wrote about <span class="docEmphasis">program families</span> a couple of decades ago, we will see in <A class="docLink" HREF="0321154959_ch14.html#ch14">Chapter 14</A> that organizational, process, and managerial concerns predominate in the successful development of <span class="docEmphasis">product lines</span>, their conceptual descendant. While Dijkstra wrote about separation of concerns about a quarter-century ago, <span class="docEmphasis">objects</span> (the conceptual descendant) have only fairly recently come into their own as a standard, widely accepted design approach. And while Brooks and Blaauw wrote about architecture even longer ago, we've already seen that architectures cannot be understood except in light of the business issues that spawned them, and we will see ways to analyze architectures without waiting for the system to be built.</P>
<P class="docText">Today, architecture as a field of study is large and growing larger, primarily because it has left the realm of deep thinkers and visionaries and made the transition into practice. The early ideas have been refined and applied enough so that it is becoming an accepted state-of-the-practice approach to system building.</P>
<P class="docText"><span class="docEmphasis">— PCC</span></P>
</TD></TR></TABLE></P>

<ul></ul>
</td>
</tr>
</table>
<td></td>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<td class="tt1"><a href="NFO/lib.html">[ Team LiB ]</a></td><td valign="top" class="tt1" align="right">
          <a href="0321154959_ch02lev1sec6.html"><img src="FILES/previous.gif" width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
          <a href="0321154959_ch02lev1sec8.html"><img src="FILES/next.gif" width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
</td></table>
</body></html>
